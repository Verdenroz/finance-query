//! Signal types for trading signals generated by strategies.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

use super::error::{BacktestError, Result};

/// Trading signal direction
#[non_exhaustive]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum SignalDirection {
    /// Buy / Go Long
    Long,
    /// Sell / Go Short
    Short,
    /// Exit current position
    Exit,
    /// No action
    Hold,
}

impl std::fmt::Display for SignalDirection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Long => write!(f, "LONG"),
            Self::Short => write!(f, "SHORT"),
            Self::Exit => write!(f, "EXIT"),
            Self::Hold => write!(f, "HOLD"),
        }
    }
}

/// Signal strength/confidence (0.0 to 1.0)
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub struct SignalStrength(f64);

impl SignalStrength {
    /// Create a new signal strength value
    ///
    /// # Errors
    /// Returns error if value is not between 0.0 and 1.0
    pub fn new(value: f64) -> Result<Self> {
        if !(0.0..=1.0).contains(&value) {
            return Err(BacktestError::invalid_param(
                "signal_strength",
                "must be between 0.0 and 1.0",
            ));
        }
        Ok(Self(value))
    }

    /// Create a signal strength without validation (clamped to [0.0, 1.0])
    pub fn clamped(value: f64) -> Self {
        Self(value.clamp(0.0, 1.0))
    }

    /// Get the strength value
    pub fn value(&self) -> f64 {
        self.0
    }

    /// Strong signal (1.0)
    pub fn strong() -> Self {
        Self(1.0)
    }

    /// Medium signal (0.5)
    pub fn medium() -> Self {
        Self(0.5)
    }

    /// Weak signal (0.3)
    pub fn weak() -> Self {
        Self(0.3)
    }
}

impl Default for SignalStrength {
    fn default() -> Self {
        Self(1.0)
    }
}

impl std::fmt::Display for SignalStrength {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:.2}", self.0)
    }
}

/// Metadata attached to signals for analysis
#[non_exhaustive]
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct SignalMetadata {
    /// Indicator values at signal time
    pub indicators: HashMap<String, f64>,
}

impl SignalMetadata {
    /// Create empty metadata
    pub fn new() -> Self {
        Self::default()
    }

    /// Add an indicator value
    pub fn with_indicator(mut self, name: impl Into<String>, value: f64) -> Self {
        self.indicators.insert(name.into(), value);
        self
    }
}

/// A trading signal generated by a strategy
#[non_exhaustive]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signal {
    /// Signal direction
    pub direction: SignalDirection,

    /// Signal strength/confidence
    pub strength: SignalStrength,

    /// Timestamp when signal was generated
    pub timestamp: i64,

    /// Price at signal generation
    pub price: f64,

    /// Optional reason/description
    pub reason: Option<String>,

    /// Strategy-specific metadata (indicator values, etc.)
    pub metadata: Option<SignalMetadata>,
}

impl Signal {
    /// Create a long signal
    pub fn long(timestamp: i64, price: f64) -> Self {
        Self {
            direction: SignalDirection::Long,
            strength: SignalStrength::default(),
            timestamp,
            price,
            reason: None,
            metadata: None,
        }
    }

    /// Create a short signal
    pub fn short(timestamp: i64, price: f64) -> Self {
        Self {
            direction: SignalDirection::Short,
            strength: SignalStrength::default(),
            timestamp,
            price,
            reason: None,
            metadata: None,
        }
    }

    /// Create an exit signal
    pub fn exit(timestamp: i64, price: f64) -> Self {
        Self {
            direction: SignalDirection::Exit,
            strength: SignalStrength::default(),
            timestamp,
            price,
            reason: None,
            metadata: None,
        }
    }

    /// Create a hold signal (no action)
    pub fn hold() -> Self {
        Self {
            direction: SignalDirection::Hold,
            strength: SignalStrength::default(),
            timestamp: 0,
            price: 0.0,
            reason: None,
            metadata: None,
        }
    }

    /// Check if this is a hold signal
    pub fn is_hold(&self) -> bool {
        matches!(self.direction, SignalDirection::Hold)
    }

    /// Check if this is an entry signal (Long or Short)
    pub fn is_entry(&self) -> bool {
        matches!(
            self.direction,
            SignalDirection::Long | SignalDirection::Short
        )
    }

    /// Check if this is an exit signal
    pub fn is_exit(&self) -> bool {
        matches!(self.direction, SignalDirection::Exit)
    }

    /// Set signal strength
    pub fn with_strength(mut self, strength: SignalStrength) -> Self {
        self.strength = strength;
        self
    }

    /// Set reason/description
    pub fn with_reason(mut self, reason: impl Into<String>) -> Self {
        self.reason = Some(reason.into());
        self
    }

    /// Set metadata
    pub fn with_metadata(mut self, metadata: SignalMetadata) -> Self {
        self.metadata = Some(metadata);
        self
    }
}

impl Default for Signal {
    fn default() -> Self {
        Self::hold()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_signal_strength_bounds() {
        assert!(SignalStrength::new(0.5).is_ok());
        assert!(SignalStrength::new(0.0).is_ok());
        assert!(SignalStrength::new(1.0).is_ok());
        assert!(SignalStrength::new(-0.1).is_err());
        assert!(SignalStrength::new(1.1).is_err());
    }

    #[test]
    fn test_signal_strength_clamped() {
        assert_eq!(SignalStrength::clamped(1.5).value(), 1.0);
        assert_eq!(SignalStrength::clamped(-0.5).value(), 0.0);
        assert_eq!(SignalStrength::clamped(0.7).value(), 0.7);
    }

    #[test]
    fn test_signal_creation() {
        let sig = Signal::long(1234567890, 150.0).with_reason("test signal");
        assert_eq!(sig.direction, SignalDirection::Long);
        assert_eq!(sig.timestamp, 1234567890);
        assert_eq!(sig.price, 150.0);
        assert_eq!(sig.reason, Some("test signal".to_string()));
        assert!(sig.is_entry());
        assert!(!sig.is_hold());
        assert!(!sig.is_exit());
    }

    #[test]
    fn test_signal_hold() {
        let sig = Signal::hold();
        assert!(sig.is_hold());
        assert!(!sig.is_entry());
        assert!(!sig.is_exit());
    }

    #[test]
    fn test_signal_metadata() {
        let metadata = SignalMetadata::new()
            .with_indicator("rsi", 30.0)
            .with_indicator("sma_20", 150.0);

        let sig = Signal::long(0, 0.0).with_metadata(metadata);
        let meta = sig.metadata.unwrap();
        assert_eq!(meta.indicators.get("rsi"), Some(&30.0));
        assert_eq!(meta.indicators.get("sma_20"), Some(&150.0));
    }
}
